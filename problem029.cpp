//Kevin Yeap
/*========== Project Euler: Problem 29 ==========
Distinct powers
Problem 29

Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    2^2=4,  2^3=8,   2^4=16,  2^5=32
    3^2=9,  3^3=27,  3^4=81,  3^5=243
    4^2=16, 4^3=64,  4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
=========================*/

/*========== program design notes ==========
first find all the possible numbers by cycling through every possible, permutation. θ(n^2), where n = the limit. in this case, 100
then run merge sort on the whole data set and while you're sorting you can delete duplicate values. O(nlogn)

answer will be how big the data set is after the merge is done.

=========================*/

/*========== program output ===========
        == Project Euler: Problem 29 ==

answer: 9183
=========================*/
  
#include <iostream>
#include <vector>
#include "BigIntegerLibrary.hh"
using namespace std;

BigUnsigned count_powers(int limit);
void merge_sort_delete(vector<BigUnsigned>& vector);
BigUnsigned big_pow(BigUnsigned x, int y);

int main() {
  int limit = 100;
  BigUnsigned result = count_powers(limit);
  
  cout << "\t== Project Euler: Problem 29 ==" << endl << endl; 
  cout << "answer: " << result << endl << endl; 
  
  return 0;
}

//finds number of unique values of a^b, when 2 ≤ a ≤ limit, and 2 ≤ b ≤ limit
BigUnsigned count_powers(int limit) {
  vector<BigUnsigned> powers;
  
  for(int i = 2; i <= limit; i++) {
    for (int j = 2; j <= limit; j++) {
      powers.push_back(big_pow(i, j));
    }
  }
  
  merge_sort_delete(powers);
  
  //best way instead of this would be to detect duplicates when merging then discard them.
  //count the non duplicates.
  int z = 1;
  int size = powers.size();
  for (int i = 1; i < size; i++) {
    if (powers[i] == powers[i-1]) z--;
    z++;
  }
  
  return z;
}

//merge sorts the vector while deleting duplicate values.
void merge_sort_delete(vector<BigUnsigned>& vec) {
  int half = vec.size()/2;
  
  vector<BigUnsigned> subset1(vec.begin(), vec.begin()+half);
  vector<BigUnsigned> subset2(vec.begin()+half, vec.end());
  
  //divide partitions in half until there each subset is 1 element in size
  if (subset1.size() > 1) { merge_sort_delete(subset1); }
  if (subset2.size() > 1) { merge_sort_delete(subset2); }
  
  int a = 0;
  int b = 0;
  int i = 0;
  int s = subset1.size();
  int t = subset2.size();
   
  //merging the two subsets into 1
  while (a < s && b < t) {
    if (subset1[a] < subset2[b]) { 
      vec[i] = subset1[a];
      a++; i++;
    } else {
      vec[i] = subset2[b];
      b++; i++;
    }
    //if (i > 1 && vec[i-1] == vec[i-2]) { vec.erase(vec.end()); i--; }
  }
  //place the rest of the leftover elements into the array
  while (a < s) {
    vec[i] = subset1[a];
    a++; i++;
    //if (i > 1 && vec[i-1] == vec[i-2]) { vec.erase(vec.end()); i--; }
  }
  while (b < t) {
    vec[i] = subset2[b];
    b++; i++;
    //if (i > 1 && vec[i-1] == vec[i-2]) { vec.erase(vec.end()); i--; }
  }
}

BigUnsigned big_pow(BigUnsigned x, int y) {
  if (y == 0) return 1;
  return (x * big_pow(x, y-1));
}
